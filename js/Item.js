      //Base class
      //these should always be created as an array: "baseItem[554] = new BaseItem(ob)" where the item id == "554" for lookup purposes
      //these class definitions should ALWAYS be created before the Item declarations
      //benchmark the hell out of this...
      function BaseItem(ob) {
        var o = {
          _id: ob.id, //are we really going to need this here?  Yes.  Yes, we are.  Shut up, Flint.
          _type: ob.type, //this will help define the directory path for the src
          _cost: ob.cost,
          _name: ob.name,
          _release_date: ob.release_date,

          //getters
          get id() {
            return this._id;
          },
          get type() {
            return this._type;
          },
          get cost() {
            return this._cost;
          },
          get name() {
            return this._name;
          },
          get releaseDate() {
            return this._release_date;
          }
        }
        return o;
      }


      //actual Item class (used in habitats)
      function Item(ob) {
        var o = {
          // _baseItem:baseItems[bin],
          // _baseName:baseItems[bin].name,
          _baseId: ob.base_id,
          _hasPalette: ob.palette,
          _src: ob.src,
          _type: ob.type,
          _isSprite: (ob.is_sprite == 1) ? true : false,
          _wid: ob.wid || 0,
          _widgetData: ob.widgetData || {},
          _spriteInitialized: false,
          _sprite: undefined,
          _fullInit: false,
          _frameCount: ob.frame_count, //required
          _frameHeight: ob.frame_height,
          _frameWidth: ob.frame_width,
          _frames: [], //generated in init()
          _isEffect: (ob.is_effect == 1) ? true : false,
          _effectID: ob.effect_id,
          _rooms: ob.rooms,
          _roomDir: ob.room_dir,
          _startRoom: ob.start_room,

          _name: ob.name,
          _id: ob.id, //unique item id (primary key for database)
          _pid: ob.pid, //player id (secondary key for database and inventory)
          _active: ob.active, //bool: currently used in a habitat?
          _z: ob.z, //z-index
          _x: ob.x, //css 'left' (applied to div container)
          _y: ob.y, //css 'top' (applied to div container)
          _r: ob.r, //css 'rotation' (applied to div container)
          _m: ob.m, //mirror (css scaleX, applied to img as a -1 or 1)
          _s: ob.s, //scale (css scaleY and *scaleX)
          _hr: ob.hr, //hue-rotation
          _hid: ob.hid, //habitatID
          _con: $("#item_" + ob.id), //container (jQuery friendly div container handle) [null is used to differentiate from 'undefined']  ..should be generated by PHP
          _img: $("#item_" + ob.id + "_img"), //image (jQuery friendly img tag handle) [null is used to differentiate from 'undefined']  ..should be generated by PHP
          _palette: null, //this gets checked and set in the activate() method
          _temp: {},
          _data: {},

          //getters
          get baseId() {
            return this._baseId;
          },
          get name() {
            return this._name;
          },
          get type() {
            return this._type;
          },
          get isSprite() {
            return this._isSprite;
          },
          get wid() {
            return this._wid;
          },
          get widgetData() {
            return this._widgetData;
          },
          get spriteInitialized() {
            return this._spriteInitialized;
          },
          get sprite() {
            return this._sprite;
          },
          get fullInit() {
            return this._fullInit;
          },
          get frameCount() {
            return this._frameCount;
          },
          get frameHeight() {
            return this._frameHeight;
          },
          get frameWidth() {
            return this._frameWidth;
          },
          get isEffect() {
            return this._isEffect;
          },
          get effectID() {
            return this._effectID;
          },
          get rooms() {
            return this._rooms;
          },
          get roomDir() {
            return this._roomDir;
          },
          get startRoom() {
            return this._startRoom;
          },
          get id() {
            return this._id;
          },
          get pid() {
            return this._pid;
          },
          get src() {
            return this._src;
          },
          get active() {
            return this._active;
          },
          get z() {
            return this._temp._z || this._z;
          },
          get x() {
            return this._temp._x || this._x;
          },
          get y() {
            return this._temp._y || this._y;
          },
          get rotate() {
            return this._temp._r || this._r;
          },
          get m() {
            return this._temp._m || this._m;
          },
          get scale() {
            return this._temp._s || this._s;
          },
          get hr() {
            return this._temp._hr || this._hr;
          },
          get hid() {
            return this._hid;
          },
          get container() {
            return this._con;
          },
          get image() {
            return this._img; /*return $("#item_" + this._id + "_img");*/
          },
          get hasPalette() {
            return this._hasPalette;
          },
          get palette() {
            return this._palette;
          },
          get data() {
            return this._data;
          },

          //setters
          set spriteInitialized(v) {
            this._spriteInitialized = v;
          },
          set fullInit(v) {
            this._fullInit = v;
          },
          set baseId(v) {
            this._baseId = v;
          },
          set src(v) {
            this._src = v;
          },
          set name(v) {
            console.error("cannot change baseSrc for " + this)
          },
          set type(v) {
            console.error("cannot change type for " + this)
          },
          set id(v) {
            console.error("cannot change id for " + this)
          },
          set pid(v) {
            console.error("cannot change pid for " + this)
          }, //trade will work around this
          set container(v) {
            console.error("cannot change container for " + this)
          },
          set image(v) {
            console.error("cannot change image for " + this)
          },
          set data(v) {
            this._data = v;
          },
          set active(v) {
            this._active = v;
            this._temp._active = v;
            //either add or remove item from habitat and send stuff through the database
          },
          set z(v) {
            this._temp._z = v;
            this._con.css("z-index", v);
          },
          set x(v) {
            this._temp._x = v;
            this._con.css("left", v + "px");
          },
          set y(v) {
            this._temp._y = v;
            this._con.css("top", v + "px");
          },
          set rotate(v) {
            this._temp._r = v;
            this._con.css('-moz-transform', 'rotate(' + v + 'deg)');
            this._con.css('-moz-transform-origin', '50% 50%');
            this._con.css('-webkit-transform', 'rotate(' + v + 'deg)');
            this._con.css('-webkit-transform-origin', '50% 50%');
            this._con.css('-o-transform', 'rotate(' + v + 'deg)');
            this._con.css('-o-transform-origin', '50% 50%');
            this._con.css('-ms-transform', 'rotate(' + v + 'deg)');
            this._con.css('-ms-transform-origin', '50% 50%');
          },
          set scale(v) { //setting the scale of the image and checking for mirroring
            // console.log("scale::", v);
            var scale = Number(v); //Math.round( v /10 * 10 ) / 10;  //computers are incredibly stupid at times...and they need a little help

            if (this.isSprite) {
              scale = Math.round(scale * 10) / 10;
            }

            this._temp._s = scale;
            var m = (this._temp._m == "1") ? -1 : 1; //check for mirroring...not recognizing 1 and 0 as t/f is really annoying...
            this._img.css({
              '-webkit-transform-style': ' preserve-3d',
              '-webkit-transform': 'scaleY(' + scale + ') scaleX(' +
                scale * m + ')', // Chrome 4+, Op 15+, Saf 3.1, iOS Saf 3.2+
              '-moz-transform': 'scaleY(' + scale + ') scaleX(' + scale *
                m + ')', //FX 3.5-15
              '-ms-transform': 'scaleY(' + scale + ') scaleX(' + scale *
                m + ')', //IE 9
              '-o-transform': 'scaleY(' + scale + ') scaleX(' + scale *
                m + ')', //Op 10.5-12
              'transform': 'scaleY(' + scale + ') scaleX(' + scale * m +
                ')' //Fx 16+, IE10+
            });
          },
          set hr(v) {
            this._temp._hr = v; //set the css hue-rotation of the _img
            this._img.css("filter", "hue-rotate(" + v + "deg)");
            this._img.css({
              '-webkit-filter': 'hue-rotate(' + v + 'deg)'
            });
          },
          set hid(v) {
            this._temp._hid = v;
            //set the habitat id of the item in the database
          },
          mirror: function() {
            if (this._temp._m == undefined) this._temp._m = this._m;
            this._temp._m = !this._temp._m;
            this.scale = this.scale; // * 10;
          },

          //methods
          init: function(preloaded) {
            // console.log("Item::init", preloaded, this);
            if (this.isSprite) {
              for (var i = 0; i < this.frameCount; i++) this._frames[i] = i;
              // if (this.render()) return true;
            }
            // console.log("initializing item " + this._id + ":");
            // console.log("\tr: " + this._r + ", s: " + this._s + ", m: " + this._m + ", z: " + this._z + ", img: " + this._img.attr('src') + "\n");
            if (this.type != 'habitat' && this.type != 'effect') {
              this._palette = ($("#item_" + ob.id + "_palette").attr("id") !=
                undefined) ? $("#item_" + ob.id + "_palette") : null;
              this.x = this._x;
              this.y = this._y;
              if (this._m) {
                this._temp._m = this._m;
              };
              this.scale = this._s; //*10;  //fix for smaller database
              this.rotate = this._r;
              this.hr = this._hr;
              if (preloaded) {
                this.z = this._z;
                zArray.push(this);
                this._con = $("#item_" + this._id);
                this._img = $("#item_" + this._id + "_img");

                var me = this;
                var img = this._img;
                var tempImg = new Image();
                tempImg.onload = function() {
                  if (me.isSprite) {
                    // img.css('background-image', 'url('+me._src+')');
                    // me._fullInit = true;
                    var aoi = "default";
                    var anims = {};
                    var sprite = new Sprite({
                      id: me._id,
                      framecount: me.frameCount,
                      src: me._src,
                      width: me.frameWidth,
                      height: me.frameHeight,
                      loop: true,
                      animations: anims,
                      animationOnInit: aoi
                    });

                    if (sprite.init()) {
                      // console.log("initializing sprite", sprite);
                      me._sprite = sprite;
                      me._fullInit = true;
                      img.css("background-image", "none"); //clear out the placeholder
                      sprite.setClass("centerHV");
                      sprite.appendTo(img);
                      sprite.start(); //for initialization
                    } else {
                      console.error("failed to load sprite");
                    }
                    if (me.wid > 0) {
                      me.widget = getWidget(me.widgetData.type, me.widgetData
                        .data).attach(me.sprite);
                    }

                    var iw = me.frameWidth;
                    var ih = me.frameHeight;
                  } else {
                    img.attr('src', me._src);
                    var iw = this.width;
                    var ih = this.height;
                  }
                  img.css("top", ih * -.5 + "px");
                  img.css("left", iw * -.5 + "px");
                  // if (me.isSprite) me.play();
                  // me.toStage(true);
                }
                tempImg.src = this._src;



              } else {
                this.active = 1;
                return this.toStage();
              }
            } else {
              //multi-room check
              if (!preloaded && this.type == 'habitat' && habitatItem !=
                undefined) {
                if (habitatItem.rooms > 1 && habitatItem != this) {

                  if (confirm(
                      "Whoa there!\nYou're about to switch to a habitat with fewer rooms.\nAll of your items (except your Pal) will be put back into your inventory.\nAre you sure you want to do that?"
                    )) {
                    $("#innerHab").css({
                      top: "0px",
                      left: "0px"
                    }); //this will need to change to the startRoom property
                    currentRoom = 1; //defaulting this in hard-code for the time being
                    confirmEmptyHabitat();
                  } else {
                    inventoryObjects["item_" + this.baseId].ids.push(this.id)
                      // console.log("killed");
                    return;
                  }
                }
                if (this.rooms > 1) {
                  enableRoomController();
                } else {
                  disableRoomController();
                  paramQuery({
                    update: 'habitat',
                    id: habitatID,
                    values: {
                      current_room: currentRoom
                    }
                  }, validateRoomUpdate);
                  // centerPal();
                }
              }

              this.z = (this.type == 'habitat') ? -1 : 1000;
              this.active = 1;
              if (preloaded) {
                return this.toStage(true);
              } else {
                return this.toStage();
              }
            }
          },
          toStage: function(pre) { //create the container and image div
            // console.log("Item.toStage()");
            if ($("#roomController").hasClass("centerHV"))
              toggleRoomController(); //hide the controller if someone adds an item
            var preloaded = (pre != undefined && pre == true) ? true :
              false;
            // console.log(this._name + this._id + "::toStage");
            if (this.type == "habitat") {
              // console.warn("Loading habitat:", this);
              //$("#habitat").css('background-image', "url('"+this._src+"')");


              var background = $("#habBackground");
              background.empty();

              if (parseInt(this.wid) === 0 || this.wid == '0') {
                // console.warn("background: ", background);
                var img = $("<img/>", {
                  src: this._src
                });
                img.css("z-index", "-1");
                this._img = img;
                background.append(img);
              } else {
                //insert the habby widget
                // console.log("widgetData", this.widgetData);
                // console.log(this);
                this.widget = getWidget('ParallaxHabby',
                  this.widgetData.data
                ).init(background);
              }


              if (!preloaded) { //remove the old one
                if (habitatItem != this) {
                  updateInventory(this._baseId);
                  habitatItem.toInventory();
                }
              }
              habitatItem = this;
              initRoomController();

              if (this._hasPalette == 1) { //stupid boolean changes between languages...
                this.createPalette();
                this.hr = this._hr;
                showHabPaletteButton();
              } else {
                hideHabPaletteButton();
              }

              console.log(
                "Some days, it's just not worth chewing through the leather straps..."
              );
              if (!preloaded) {
                this.hid = habitatID;

                this.commitTemp();
                paramQuery({
                  update: 'habitat',
                  id: habitatID,
                  values: {
                    "inv_id": this.id,
                    "item_id": this._baseId
                  }
                }, validateSave);
                console.log("saving values to habitat");
              }

            } else if (this.type == "effect") {
              //console.log("adding effect...");
              fxList.push(this);
              var hab = $("#habitat");
              showFXButton();
              if ($("#fxLayer").attr('id') == undefined) {
                hab.append($("<div/>", {
                  id: "fxLayer"
                }));
              }
              var fxLayer = $("#fxLayer");
              paramQuery({
                target: "fxLayer",
                effectID: this.effectID
              }, loadEffect, 'fetch_effect');

              var io = inventoryObjects["item_" + this._baseId];
              if (io != undefined) io.available--;

              updateInventory(this._baseId);
              this.hid = habitatID;
              this.commitTemp();

            } else { //other items
              sounds.addItem.play();
              if (this._con.attr("id") == undefined) { //container does not exist in habitat, so create it
                // console.log("creating item");
                var me = this; //for internal img.load() function
                var con = $("<div />", {
                  id: "item_" + this._id,
                  class: "item_hab",
                  item_id: this._id
                });

                if (this.isSprite) {
                  // console.log("rendering sprite");
                  var img = $("<div/>", {
                    id: "item_" + this._id + "_img",
                    class: "item",
                    style: "height:" + this.frameHeight + "px; width:" +
                      this.frameWidth + "px;"
                  });
                } else {
                  var img = $("<img />", {
                    id: "item_" + this._id + "_img",
                    class: "item",
                    item_id: this._id
                  });
                }

                var tempImg = new Image();
                var me = this;

                tempImg.onload = function() {
                  if (me.isSprite) {
                    var aoi = "default";
                    var anims = {};
                    var sprite = new Sprite({
                      id: me._id,
                      framecount: me.frameCount,
                      src: me._src,
                      width: me.frameWidth,
                      height: me.frameHeight,
                      loop: true,
                      animations: anims,
                      animationOnInit: aoi
                    });

                    if (sprite.init()) {
                      // console.log("initializing sprite", sprite);
                      me._sprite = sprite;
                      me._fullInit = true;
                      img.css("background-image", "none"); //clear out the placeholder
                      sprite.setClass("centerHV");
                      sprite.appendTo(img);
                      sprite.start(); //for initialization
                      sprite.pause();
                    } else {
                      console.error("failed to load sprite");
                    }
                    if (me.wid > 0) {
                      // console.log("widgetData", me.widgetData);
                      me.widget = getWidget(me.widgetData.type, me.widgetData
                        .data).attach(me.sprite);
                    }

                    var iw = me.frameWidth;
                    var ih = me.frameHeight;


                  } else {
                    img.attr('src', me._src);
                    var iw = this.width;
                    var ih = this.height;
                  }
                  img.css("top", ih * -.5 + "px");
                  img.css("left", iw * -.5 + "px");
                  //we're going to center the item once it actually loads, both in it's container, and in the habitat...this could get interesting...
                  // var hw = 1126;//$("#habitat").width();
                  // var hh = 430;//$("#habitat").height();


                  me.x = 563;
                  me.y = 215;
                  //now to modify for multi-room habbies
                  if (currentRoom != 1) {
                    // console.log("adding item to room " + currentRoom);
                    switch (habitatItem.roomDir) {
                      case "hv":
                        if (currentRoom == 2 || currentRoom == 4) me.x +=
                          1126;
                        if (currentRoom == 3 || currentRoom == 4) me.y +=
                          430;
                        break;
                      case "v":
                        me.y += (currentRoom - 1) * 430;
                        break;
                      case "h":
                        me.x += (currentRoom - 1) * 1126;
                        break;
                      default:
                        console.error("WTF?");
                        break;
                    }
                  }

                  //now do the other important stuffs...
                  me.hid = habitatID;
                  if (!preloaded) me.z = zArray.length;
                  me.rotate = 0;
                  me.hr = 0;
                  me._m = 0;
                  me.scale = .66;

                  showRotate();

                  me.commitTemp();
                }

                tempImg.src = this._src;
                // console.log("toStage:", this);

                zArray.push(this);
                con.append(img);
                // $("#habitat").append(con);
                $("#innerHab").append(con);
                this._con = con;
                this._img = img;
                cItem = this; //set the current item
                if (this._hasPalette == 1) { //stupid boolean changes between languages...
                  this.createPalette();
                }
                this.activate(this.isSprite);

                //modify the inventory panel
                var io = inventoryObjects["item_" + this._baseId];
                if (io != undefined) io.available--;
                updateInventory(this._baseId);
                return true;

              } else {
                //...?
                //if the container already exists on the stage, we have an issue
              }
            }
          },
          center: function() {
            //why do I even have this here?
          },
          toInventory: function(sort) {
            if (sort == undefined) sort = true;
            if (this.type == 'pet') {
              popNotify("You cannot remove your Pal from the habitat");
              return;
            }
            sounds.removeItem.play();
            if (this.isSprite)
              if (this.fullInit)
                if (this.spriteInitialized) this.pause();
            this.fullInit = false;
            this.spriteInitialized = false;

            var t = this._temp;

            t["_active"] = 0; //make this stick...
            t["_hid"] = t["_x"] = t["_y"] = t["_z"] = t["_r"] = t["_hr"] =
              t["_m"] = 0;
            t["_s"] = 1; //reset editing variables (in _temp)
            if (this.type == 'habitat') {
              this.commitTemp();
              if (this.wid > 0) {
                this.widget.onRemove();
              }
            } else if (this.type == 'effect') {
              fxList.splice(fxList.indexOf(this), 1);
              this.commitTemp();
            } else {
              this._con.remove(); //remove the container and child elements from the stage
              this.deactivate();
              this.commitTemp();
              if (sort) removeFromZ(this, sort);
            }
            //put this._id back into the available ids for the inventory
            if (inventoryObjects["item_" + this._baseId] != undefined) {
              inventoryObjects["item_" + this._baseId].available++;
            }
            // inventoryObjects["item_" + this._baseId].ids.push(this._id);
            inventoryQuery({pid:playerID, id:this._id, itemID:this._baseId}, undefined, 'store_item');
            updateInventory(this._baseId);
          },
          clearPalette: function() {
            if ($("#item_" + this._id + "_palette").attr('id') != undefined) {
              $("#item_" + this._id + "_palette").remove();
            }
          },
          createPalette: function() {
            // console.log(this._name + this._id + "::createPalette");
            var basePaletteStyle = "";
            if ($("#item_" + this._id + "_palette").attr('id') != undefined) {
              this._palette = $("#item_" + this._id + "_palette");
              return;
            }
            var itemPalette = $("<div />", {
              id: "item_" + this._id + "_palette",
              class: "palette"
            });
            // console.log("appending: " + itemPalette.attr("id"));
            for (var i = 0; i == i; i++) {
              if ((HR_INCREMENT * i) > 359) break;
              if (pCSS) basePaletteStyle += ".p" + i +
                " { -webkit-filter : hue-rotate(" + (i * HR_INCREMENT) +
                "deg); -o-filter : hue-rotate(" + (i * HR_INCREMENT) +
                "deg); filter : hue-rotate(" + (i * HR_INCREMENT) +
                "deg); width:auto; height:25px; display:inline-block; margin-right:2px; margin-left:2px; }"; //this is in case there isn't already a style built out on the page

              if (this.isSprite) {
                var hAdjust = 25 / this.frameHeight;
                var wAdjust = 25 / this.frameWidth;
                var pScale = (hAdjust < wAdjust) ? hAdjust : wAdjust;
                var pStyle = "-webkit-transform:scale(" + pScale +
                  ");-moz-transform:scale(" + pScale +
                  ");-ms-transform:scale(" + pScale +
                  ");-o-transform:scale(" + pScale + ");transform:scale(" +
                  pScale +
                  ");-webkit-transform-origin:top left;-moz-transform-origin:top left;-ms-transform-origin:top left;-o-transform-origin:top left;transform-origin:top left;";

                var thisP = $("<div/>", {
                  style: "display:inline-block;margin-right:2px;margin-left:2px; overflow:hidden;height:" +
                    this.frameHeight * pScale + "px; width:" + this.frameWidth *
                    pScale + "px;"
                })
                thisP.append($("<div/>", {
                  id: "p" + i,
                  class: "p" + i,
                  onclick: "rotatePalette(this);",
                  style: "background-image:url(" + this.src +
                    "); height:" + this.frameHeight + "px; width:" +
                    this.frameWidth +
                    "px; overflow:hidden;display:inline-block; overflow:hidden; display:inline-block;position:relative;vertical-align:top;" +
                    pStyle
                }));
                itemPalette.append(thisP);
              } else {
                itemPalette.append($("<img />", {
                  id: "p" + i,
                  src: this._src,
                  class: "paletteItem p" + i,
                  onclick: "rotatePalette(this);"
                }));
              }
              $("#cbPalette").append(itemPalette);
            }
            this._palette = itemPalette;

          },
          commitTemp: function() {
            var key;
            var changes = {};
            var c = "";

            if (this._temp.hid == 0) {
              console.log("removing item", this);

              return;
            }
            if (arguments[0] != undefined) { //commit single argument
              changes[arguments[0].split("_")[1]] = this._temp[arguments[0]];
              if (key == "_s" && this._temp[key] == 0) return;
              this[key] = this._temp[key]; //set the object variable to match the temp value
              paramQuery({
                update: "inventory",
                id: this._id,
                values: changes
              }, validateSave);
            } else { //commit all
              // console.error("commitTemp", this._temp);
              for (key in this._temp) { //build the update string
                if (typeof this._temp[key] !== 'function') changes[key.split(
                  "_")[1]] = this._temp[key]; //remove the underscore so that we get the real DB field name
                if (key == "_s" && this._temp[key] == 0) return;
                this[key] = this._temp[key]; //set the object variable to match the temp value
              }
              if (Object.keys(this._temp).length == 0) return;
              console.error(
                "\tCommitting (crimes against linear developers) -> ",
                changes); //do something cheeky so that we know what the heck is going on
              paramQuery({
                update: "inventory",
                id: this._id,
                values: changes
              }, validateSave);
              delete this._temp;
              this._temp = {};
            }
          },
          activate: function(firstLoad) {
            if (this.isSprite) {
              this.pause();
            }
            habitatItem.commitTemp();
            this._img.addClass("item_editing");
            this._img.on('mousedown touchstart', function(e) {
              startDrag(e);
            });
            setSlider(this.scale * 10);
            cItem = this;
            if (habitatItem._palette != null) habitatItem._palette.hide();
            if (this._palette != null) {
              this._palette.show();
              showPalette();
            } else {
              hidePalette();
            }
            return true;
          },
          deactivate: function() {
            if (this.isSprite) {
              this.play();
            }
            saveChanges();
            this._img.removeClass("item_editing");
            this._img.on('mousedown touchstart', function(e) {
              startDrag(e);
            });
            delete this._data;
            this._data = {};
            if (this._palette != null) this._palette.hide();
            cDegrees = null;
            cItem = null;
            return true;
          },

          //sprite methods
          play: function() {
            if (!this.isSprite) return;
            if (!this.fullInit) {
              setTimeout(this.play, 300);
              return;
            }
            // this.fullInit = true;
            if (this.spriteInitialized) {
              // this._img.animateSprite('resume');
              this.sprite.start();
            } else {
              if (this.sprite != undefined) this.sprite.start();

              this.spriteInitialized = true;
              // this._img.animateSprite({
              //   fps: 24,
              //   animations: {
              //     looping: this._frames
              //   },
              //   loop: true,
              //   complete: function() {
              //     // use complete only when you set animations with 'loop: false'
              //     alert("animation End");
              //   }
              // });
            }
          },
          pause: function() {
            if (!this.isSprite) return;
            if (!this.fullInit) {
              setTimeout(this.pause, 300);
              return;
            }
            if (this.spriteInitialized) {
              this.sprite.pause();
              // this._img.animateSprite('stop');
              // this._img.animateSprite('frame', 0);
            }
          },
          click: function() {
            if (this.isSprite) {
              this.sprite.click();
            }
          },
          highlight: function() {
            console.log("highlighting item");
            this._img.addClass("blueglow");
            var im = this._img;
            setTimeout(function() {
              im.removeClass("blueglow")
            }, 2000);
          }

        }
        return o;
      }
